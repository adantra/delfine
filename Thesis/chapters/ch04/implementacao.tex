\chapter{Implementação Computacional}
\label{ch:implementacao}

Todas as formulações, tanto matemática quanto numéricas, utilizadas neste trabalho apresentam grandes desafios, não apenas no que tange a compreensão teórica, mas também em relação ao desenvolvimento propriamente dito do software, já que é de fundamental importância uma implementação adequada destes métodos a fim de se atingir um compromisso vantajoso entre generalidade e performance computacional, pois este dois objetivos frequentemente tendem a conduzir as diretivas de codificação do programa para direções diferentes.

Este capítulo se propõe a apresentar o modo como o programa de computador resultante deste trabalho foi elaborado, sendo que para isto foi adotada uma descrição \emph{top-down}, ou seja, primeiramente são expostas as características gerais do programa e em seguida as divisões do mesmo em diferentes blocos que permitem uma melhor abordagem do problema. Cada um destes blocos é então subdivido em partes menores, as quais correspondem a tarefas específicas, que podem ter suas soluções diretamente codificadas utilizando uma linguagem de programação ou então serem resolvidas através de alguma biblioteca de software disponível na internet.

Outro aspecto a ser comentado a respeito da filosofia de desenvolvimento do programa é justamente que se buscou sempre utilizar soluções já prontas disponíveis publicamente, de modo a evitar o fenômeno popularmente conhecido como "reinventar a roda". Além disso, foi dada preferência explícita a pacotes publicados segundo licenças livres (e.g., GNU GPL, BSD License, etc.), as quais permitem o uso, estudo, adaptação e redistribuição de programas de modo bastante transparente. Logicamente, o resultado deste trabalho também está disponível através de uma licença livre. No Apêndice \ref{ch:manual} se encontra um manual com instruções para a obtenção, instalação e uso do software desenvolvido.

\section{Estrutura Geral do Programa}
\label{sc:est_prog}
A resolução de um problema através de um método numérico pode normalmente ser dividida em três etapas distintas:
\begin{itemize}
\item \emph{Pré-processamento}: Definição de uma geometria que aproxime o domínio real e geração de uma malha de pontos discretos para a mesma. Além disso, nesta etapa são fornecidas as condições de contorno e propriedades que buscam representar o problema real. Também nesta fase são definidos os parâmetros da análise efetuada no passo a seguir.
\item \emph{Processamento}: Cálculo propriamente dito dos valores para as variáveis de interesse. Para isto, é utilizada alguma formulação numérica específica que trate adequadamente a descrição matemática do problema. Os resultados obtidos nesta etapa são analisados criticamente na fase seguinte.
\item \emph{Pós-processamento}: Visualização e interpretação dos resultados fornecidos pela etapa de processamento. Caso a resposta obtida seja satisfatória, a resolução do problema é encerrada neste ponto. Caso contrário, alterações são feitas na etapa de pré-processamento e o ciclo é reiniciado até que se atinja o objetivo.
\end{itemize}

Esta divisão também foi considerada no desenvolvimento do \emph{Delfine}, sendo este o nome do programa desenvolvido neste trabalho. Os blocos responsáveis por executar cada uma das tarefas descritas anteriormente serão apresentados na forma de fluxograma e detalhados nas seções seguintes. 

\section{Pré-Processamento}
\label{sc:pre-proc}

Na Fig. \ref{fig:preprocessadorflux} pode ser visto um fluxograma representando os vários passo necessários para a obtenção, a partir de um problema real, de um problema discreto passível de ser analisado numericamente.

Inicialmente, é necessário por parte do usuário ter uma descrição o mais precisa possível do problema de interesse. De posse da mesma, parte-se para as etapas de discretização da geometria (i.e., geração da malha) e de definição de uma arquivo de entrada de dados.

O \emph{Delfine} oferece três caminhos para a obtenção da malha: através de um gerador interno do \emph{FEniCS/Dolfin}, o qual é utilizado principalmente na parte de processamento, porém disponibiliza algumas rotinas básicas de geração de malhas, com a vantagem de tornar o programa independente de qualquer programa externo para este fim, já que os parâmetros para definição de malha são definidos no próprio arquivo de entrada de dados da simulação. Porém, como grande desvantagem podemos citar o fato da limitação quanto às geometrias disponíveis, pois apenas formas primitivas como linhas, retângulos, círculos, paralelepípedos e esferas podem ser descritos usando esta ferramenta.

Uma segunda alternativa é o uso da ferramenta \emph{Gmsh} \citep{Geuzaine2009}, a qual apresenta como vantagem uma maior flexibilidade na definição da geometria, pois este gerador disponibiliza várias operações que podem ser executadas em formas primitivas para a obtenção de outras mais complexas. Entre estas operações podemos citar adição, subtração, extrusão, escalonamento, divisão, entre outras. Além disso, o \emph{Gmsh} dispõe de uma meta-linguagem própria que possibilita a escrita de scripts para a automatização e parametrização da geração de malhas. Como desvantagem, temos a necessidade de conversão do arquivo no formato *.msh gerado pelo \emph{Gmsh} para o padrão utilizado pelo \emph{Delfine}, o qual é derivado diretamente do formato utilizado pelo \emph{FEniCS/Dolfin}. Esta conversão é feita utilizando o script \emph{delfine-convert}.

% Arrumar citacao para todos os programas abaixo.
Como terceira e última alternativa temos o uso de outros gerador de malhas disponíveis publicamente ou não, como por exemplo o \emph{Triangle}, o \emph{Medit}, o \emph{ExodusII} ou o pré-processador do \emph{Abaqus}. Como vantagem desta alternativa podemos citar a liberdade em relação ao tipo de gerador de malhas a ser utilizado, já que o usuário pode escolher aquele com o qual tem mais familiaridade. Porém, os arquivos nos formatos de saída de qualquer um dos programas citados terá que ser convertido para o formato padrão do \emph{Delfine} utilizando o script \emph{dolfin-convert} \citep{Logg2010}.

A diferença básica entre a segunda e a terceira alternativas reside exatamente no tipo de script utilizado para a conversão dos arquivos de malha. O \emph{dolfin-convert} é disponibilizado como parte da família de pacotes \emph{FEniCS/Dolfin}, porém o mesmo faz apenas uma conversão das informações geométricas e topológicas da malha, ignorando às informações extras eventualmente presentes nos arquivos. Logo, não é possível importar \emph{flags} de condições de contorno definidos no \emph{Triangle} diretamente no \emph{Delfine}, por exemplo. Sendo assim, tais informações têm que ser adicionadas manualmente aos arquivos de entrada do \emph{Delfine}.

Já o \emph{delfine-convert} é uma adaptação do \emph{dolfin-convert} realizada durante este trabalho com o objetivo de importar todas as indicações de condições de contorno definidas no \emph{Gmsh} e exportá-las no formato lido pelo \emph{Delfine}. Esta funcionalidade é de fundamental importância para problemas de maior complexidade, pois permite agilizar bastante a etapa de pré-processamento. Por isto, dentre toda as citadas, a segunda alternativa foi a mais utilizada ao longo deste trabalho.

Uma vez obtida a geometria discretizada, é necessário ler o arquivo de entrada de dados, o qual contém informações a respeito das condições de contorno, propriedades de rochas e fluidos, parâmetros numéricos, etc. De um modo geral, tais informações podem ser fornecidas através de um arquivo de texto comum, desde que as mesmas estejam ordenadas de modo estruturado para serem processadas pelo programa.

Entretanto, tal abordagem não apresenta uma robustez adequada, pois permite que pequenos erros do usuário na confecção do arquivo de dados passem desapercebidos, o que pode acarretar tanto em demora para executar uma análise inicial, pois se torna necessário uma checagem manual de todos os parâmetros fornecidos até se encontrar a fonte de erro, como também se permite executar análises com valores não consistentes, os quais podem vir a gerar resultados totalmente não-físicos, podendo inclusivo levar o usuário a interpretar o fenômeno de interesse de maneira errônea.

Sendo assim, de modo a aumentar a robustez da entrada de dados se optou pelo uso de arquivos estruturados no formato \ac{XML} \citep{Bray2000} com a utilização da linguagem de especificação de esquemas \ac{RNC} \citep{Clark2001}. Esta linguagem permite definir um padrão lógico a ser seguido por qualquer arquivo \ac{XML} gerado, caso contrário o mesmo não é considerado válido e o ponto exato onde o erro na entrada de dados foi encontrado é apresentado ao usuário antes mesmo de qualquer análise ter início. Este padrão é definido através de um arquivo chamado de \emph{Schema Grammar} e todo arquivo de entrada será checado contra esta gramática através do programa \ac{RNV} \citep{Sheen2007}. Este programa é sempre chamado automaticamente pelo \emph{Delfine} antes do início da análise para verificar a entrada de dados do usuário, garantindo assim que a execução só será realizado caso exista uma consistência mínima nos dados fornecidos. Na Listagem \ref{lst:arqxmlinput} é apresentado um trecho de um arquivo de entrada típico. No mesmo pode ser observada a estrutura hierárquica utilizada para o armazenamento dos dados, os quais são tratados de modo completamente modular, ou seja, caso uma análise não precise de determinada informação, o bloco de dados referente a mesma pode simplesmente ser deixado de fora do arquivo de dados, sem prejuízo na etapa de pré-processamento.

\begin{listing}[H]
\begin{xmlcode}
<delfine>
    <geometry>
        <mesh dimension="2" order ="1" type="gmsh">
            <filename>HomoIsoBCStruct.msh</filename>
        </mesh>
        <boundary-conditions>
            <well function="inject" id="301">.250</well>
        </boundary-conditions>  
    </geometry>
    <physical>
        <rock-properties>
            <rock-type id="1">
                <porosity>1.0</porosity>
                <permeability type="per-domain">
                    <Kxx>0.50</Kxx>
                    <Kxy>0.0</Kxy>
                    <Kxz>0.0</Kxz>
                </permeability>
            </rock-type>
        </rock-properties>
    </physical>
</delfine>                            
\end{xmlcode}
\caption{Trecho de arquivo de entrada no formato *.xml.}
\label{lst:arqxmlinput}
\end{listing}

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Pre-Process}
\caption{Fluxograma da etapa de pré-processamento.}
\label{fig:preprocessadorflux}
\end{figure}

\section{Processamento}
\label{sc:proc}

Uma vez lidos na etapa de pré-processamento os arquivos necessário para a execução da análise, tem início a etapa de processamento, a qual foi implementada neste trabalho de acordo com os fluxogramas apresentados nas Figs. \ref{fig:ellipticflux} e \ref{fig:hyperbolicflux}.

O fluxograma da Fig. \ref{fig:ellipticflux} representa os passos necessário para resolver a parte elíptica do problema de escoamentos multifásicos em meios porosos. As formulações matemática e numérica deste problema adotadas neste trabalho podem ser consultadas nas seções \ref{sc:press_eq} e \ref{sc:fem}, respectivamente.

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Elliptic}
\caption{Fluxograma da resolução da parte elíptica.}
\label{fig:ellipticflux}
\end{figure}

O usuário tem a disposição duas alternativas de métodos numéricos para resolução do problema: o \acf{MEF} e o \acf{MEFM}. As diferenças entre os dois métodos do ponto de vista da formulação numérica são discutidas no capítulo \ref{ch:form_num}, sendo nesta seção discutidos apenas os aspectos de implementação. Ambos os métodos são codificados utilizando a interface na linguagem \emph{Python} da ferramenta \emph{FEniCS/DOLFIN}. A seguir faremos uma descrição geral deste pacote computacional e em seguida mostraremos como o mesmo foi utilizado neste trabalho.

\subsection{FEniCS}
\label{sc:fenics}
O \emph{FEniCS} é um projeto colaborativo em código aberto iniciado em 2003 com o objetivo automatizar a solução de modelos matemáticos baseados em equações diferenciais \citep{Logg2011}, tendo todos os seus componentes sido desenvolvidos buscando generalidade, eficiência e simplicidade.

De um modo geral, o desenvolvedor tem acesso direto principalmente ao \emph{DOLFIN}, o qual é uma biblioteca que permite a interface com o usuário através de diversas classes acessíveis via programas em \emph{C++} ou em \emph{Python}. Para facilitar a compreensão, a Fig. \ref{fig:sequencefenics} apresenta de modo esquemático a sequência na qual os diversos componentes do projeto \emph{FEniCS} são executados, e como eles interagem para permitir a resolução do problema.

Inicialmente, o problema tem que ser descrito matematicamente na sua forma variacional (ou fraca). Em seguida, esta deve ser implementada utilizando a \ac{UFL} \citep{Logg2011}, a qual é uma linguagem específica de domínio para declaração da discretização via \ac{MEF} de formas variacionais e funcionais. Para o caso de programas escritos em \emph{Python}, a descrição via \ac{UFL} é embutida dentro do próprio script, já no caso do \emph{C++} é necessário criar um arquivo externo para definição da forma fraca do problema, sendo o mesmo importado para o programa principal.

Em seguida, tais formas são compiladas utilizando o \ac{FFC} \citep{Logg2011}, o qual é o responsável de fato pela geração automática do código otimizado em linguagem de baixo-nível. Este código estará automaticamente conforme o padrão do \ac{UFC} e pode ser acessado de modo transparente através de classes da biblioteca \emph{DOLFIN}, a qual será responsável pela montagem de todos os tensores necessários para a resolução numérica do problema dentro do programa definido pelo usuário (\emph{Delfine} no caso deste trabalho, como representado na Fig. \ref{fig:sequencefenics}).

\begin{figure} 
\centering
\includegraphics[width=0.1\textwidth, angle=270]{chapters/ch04/SequenceFenics}
\caption{Interação entre os diversos componentes do projeto \emph{FEniCS} para definição do problema, seguidos pela resolução no \emph{Delfine} (adaptado de \cite{Rathgeber2010}).}
\label{fig:sequencefenics}
\end{figure}

O \emph{DOLFIN} \citep{Logg2010} automatiza a montagem dos sistemas lineares ou não-lineares provenientes da discretização via \ac{MEF} de \ac{EDP}s expressas na forma variacional.
Na Fig. \ref{fig:moduledolfin} é apresentada a estrutura modular da biblioteca, onde os dados de entrada para um problema específico são a malha, a forma variacional e os tipos de elementos finitos adotados.

\begin{figure} 
\centering
\includegraphics[width=0.5\textwidth]{chapters/ch04/ModulesDolfin}
\caption{Estrutura modular do \emph{DOLFIN} (retirado de \cite{Logg2010}).}
\label{fig:moduledolfin}
\end{figure}

\begin{listing}[H]
\begin{pythoncode}
def Galerkin(self, delfineVar, parameter):
	.
	.      
	# Define variational form
        a = inner(grad(v), K*mob*grad(u))*dx
        L = v*f*dx - g*v*ds
\end{pythoncode}
\caption{Montagem do operador elíptico via \ac{MEF} de Galerkin usando o \emph{FEniCS/DOLFIN}.}
\label{lst:arqpymfem}
\end{listing}

\begin{listing}[H]
\begin{pythoncode}
def MixedFEM(self, delfineVar, parameter):
	.
	.  
	# Define variational form
	a = (dot((invK/mob)*sigma, tau)
            - div(tau)*u - div(sigma)*v)*dx
	L = - f*v*dx
\end{pythoncode}
\caption{Montagem do operador elíptico via \ac{MEFM} usando o \emph{FEniCS/DOLFIN}.}
\label{lst:arqpymfem}
\end{listing}

A parte parabólica/hiperbólica do problema pode ser descrita pelo fluxograma apresentado na Fig. \ref{fig:hyperbolicflux}.

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Hyperbolic}
\caption{Fluxograma da resolução da parte hiperbólica.}
\label{fig:hyperbolicflux}
\end{figure}

\section{Pós-Processamento}
\label{sc:pos-proc}

\begin{figure} 
\centering
\includegraphics[width=0.7\textwidth]{chapters/ch04/Pos-Process}
\caption{Fluxograma da etapa de pós-processamento.}
\label{fig:posprocessadorflux}
\end{figure}