\chapter{Implementação Computacional}
\label{ch:implementacao}

As formulações utilizadas neste trabalho, tanto a matemática quanto as numéricas, apresentam grandes desafios não apenas no que tange à compreensão teórica, mas também em relação ao desenvolvimento propriamente dito do \emph{software}, já que é de fundamental importância uma implementação adequada destes métodos a fim de se atingir um compromisso vantajoso entre generalidade e desempenho computacional, pois este dois objetivos frequentemente tendem a conduzir as diretivas de codificação do programa para direções diferentes.

Este capítulo se propõe a apresentar o modo como o programa de computador resultante deste trabalho foi elaborado, sendo que para isto foi adotada uma descrição \emph{top-down}, ou seja, primeiramente são expostas as características gerais do programa e em seguida as divisões do mesmo em diferentes blocos que permitem uma melhor abordagem do problema. Cada um destes blocos é então subdivido em partes menores, as quais correspondem a tarefas específicas, que podem ter suas soluções diretamente codificadas utilizando uma linguagem de programação ou então serem resolvidas através de alguma biblioteca de software disponível na internet.

Outro aspecto a ser comentado a respeito da filosofia de desenvolvimento do programa é justamente que se buscou sempre utilizar soluções já prontas disponíveis publicamente, de modo a evitar o fenômeno popularmente conhecido como ``reinventar a roda''. Além disso, foi dada preferência explícita a pacotes publicados segundo licenças livres (e.g., GNU GPL, BSD License, etc.), as quais permitem o uso, estudo, adaptação e redistribuição de programas de modo bastante transparente. Logicamente, o resultado deste trabalho também está disponível através de uma licença livre. 
%No Apêndice \ref{ch:manual} se encontra um manual com instruções para a obtenção, instalação e uso do software desenvolvido.

\section{Estrutura Geral do Programa}
\label{sc:est_prog}
A resolução de um problema através de um método numérico pode normalmente ser dividida em três etapas distintas:
\begin{itemize}
\item \emph{Pré-processamento}: Definição de uma geometria que aproxime o domínio real e geração de uma malha de pontos discretos para ela. Além disso, nesta etapa são fornecidas as condições iniciais, de contorno e propriedades que buscam representar o problema real. Também nesta fase são definidos os parâmetros da análise a ser efetuada no passo a seguir.
\item \emph{Processamento}: Cálculo propriamente dito dos valores para as variáveis de interesse. Para isto, é utilizada alguma formulação numérica específica que trate adequadamente a descrição matemática do problema. Os resultados obtidos nesta etapa são analisados criticamente na fase seguinte.
\item \emph{Pós-processamento}: Visualização, cálculo de variáveis secundárias e interpretação dos resultados fornecidos pela etapa de processamento. Caso a resposta obtida seja satisfatória, a resolução do problema é encerrada neste ponto. Caso contrário, alterações são feitas na etapa de pré-processamento e o ciclo é reiniciado até que se atinja o objetivo.
\end{itemize}

Esta divisão também foi considerada no desenvolvimento do \emph{Delfine}, sendo este o nome do programa desenvolvido neste trabalho. Os blocos responsáveis por executar cada uma das tarefas descritas anteriormente serão apresentados na forma de fluxograma e detalhados nas seções seguintes. 

\section{Pré-Processamento}
\label{sc:pre-proc}

Na Fig.~\ref{fig:preprocessadorflux} pode ser visto um fluxograma representando os vários passos necessários para a obtenção, a partir de um problema real, de um problema discreto passível de ser analisado numericamente.

Inicialmente, é necessário por parte do usuário ter uma descrição o mais precisa possível do problema de interesse, envolvendo a etapa da modelagem geométrica. De posse desta, parte-se para as etapas de discretização do domínio (i.e., geração da malha) e de definição de uma arquivo de entrada de dados.

O \emph{Delfine} oferece três caminhos para a obtenção da malha. A primeira é através de um gerador interno do \emph{FEniCS/Dolfin}, o qual é utilizado principalmente na parte de processamento. Este disponibiliza algumas rotinas básicas de geração de malhas, com a vantagem de tornar o programa independente de qualquer programa externo para este fim, já que os parâmetros para definição de malha são definidos no próprio arquivo de entrada de dados da simulação. Porém, como grande desvantagem podemos citar o fato da limitação quanto às geometrias disponíveis, pois apenas formas primitivas como linhas, retângulos, círculos, paralelepípedos e esferas podem ser descritos usando esta ferramenta.

Uma segunda alternativa é o uso da ferramenta \emph{Gmsh} \citep{Geuzaine2009}, a qual apresenta como vantagem uma maior flexibilidade na definição da geometria, pois este gerador disponibiliza várias operações que podem ser executadas em formas primitivas para a obtenção de outras mais complexas. Entre estas operações podemos citar adição, subtração, extrusão, escalonamento, divisão, entre outras. Além disso, o \emph{Gmsh} dispõe de uma meta-linguagem própria que possibilita a escrita de scripts para a automatização e parametrização da geração de malhas. Como desvantagem, temos a necessidade de conversão do arquivo no formato \verb|.msh| gerado pelo \emph{Gmsh} para o padrão utilizado pelo \emph{Delfine}, o qual é derivado diretamente do formato utilizado pelo \emph{FEniCS/Dolfin}. Esta conversão é feita utilizando o script \emph{delfine-convert}.

% Arrumar citacao para todos os programas abaixo.
Como terceira e última alternativa temos o uso de outros geradores de malhas disponíveis publicamente ou não, como por exemplo o \emph{Triangle}, o \emph{Medit}, o \emph{ExodusII} ou o pré-processador do \emph{Abaqus}. Como vantagem desta alternativa podemos citar a liberdade em relação ao tipo de gerador de malhas a ser utilizado, já que o usuário pode escolher aquele com o qual tem mais familiaridade. Porém, os arquivos nos formatos de saída de qualquer um dos programas citados terá que ser convertido para o formato padrão do \emph{Delfine} utilizando o script \emph{dolfin-convert} \citep{Logg2010}.

A diferença básica entre a segunda e a terceira alternativa reside exatamente no tipo de script utilizado para a conversão dos arquivos de malha. O \emph{dolfin-convert} é disponibilizado como parte da família de pacotes \emph{FEniCS/Dolfin}, porém o mesmo faz apenas uma conversão das informações geométricas e topológicas da malha, ignorando as informações extras eventualmente presentes nos arquivos. Logo, não é possível importar \emph{flags} de condições de contorno definidos no \emph{Triangle} diretamente no \emph{Delfine}, por exemplo. Sendo assim, tais informações têm que ser adicionadas manualmente aos arquivos de entrada do \emph{Delfine}.

Já o \emph{delfine-convert} é uma adaptação do \emph{dolfin-convert} realizada durante este trabalho com o objetivo de importar todas as indicações de condições de contorno definidas no \emph{Gmsh} e exportá-las no formato lido pelo \emph{Delfine}. Esta funcionalidade é de fundamental importância para problemas de maior complexidade, pois permite agilizar bastante a etapa de pré-processamento. Por isto, dentre toda as citadas, a segunda alternativa foi a mais utilizada ao longo deste trabalho.

Uma vez obtida a geometria discretizada, é necessário ler o arquivo de entrada de dados, o qual contém informações a respeito das condições iniciais, de contorno, propriedades de rochas e fluidos, parâmetros numéricos, etc. De um modo geral, tais informações podem ser fornecidas através de um arquivo de texto comum, desde que elas estejam ordenadas de modo estruturado para serem processadas pelo programa.

Entretanto, tal abordagem não apresenta uma robustez adequada, pois permite que pequenos erros do usuário na confecção do arquivo de dados passem desapercebidos, o que pode acarretar tanto em demora para executar uma análise inicial, pois se torna necessário uma checagem manual de todos os parâmetros fornecidos até se encontrar a fonte de erro, como também se permite executar análises com valores não consistentes, os quais podem vir a gerar resultados totalmente não-físicos, podendo inclusive levar o usuário a interpretar o fenômeno de interesse de maneira errônea.

Sendo assim, de modo a aumentar a robustez da entrada de dados se optou pelo uso de arquivos estruturados no formato \ac{XML} \citep{Bray2000} com a utilização da linguagem de especificação de esquemas \ac{RNC} \citep{Clark2001}. Esta linguagem permite definir um padrão lógico a ser seguido por qualquer arquivo \ac{XML} gerado, caso contrário o mesmo não é considerado válido e o ponto exato onde o erro na entrada de dados foi encontrado é apresentado ao usuário antes mesmo de qualquer análise ter início. Este padrão é definido através de um arquivo chamado de \emph{Schema Grammar} e todo arquivo de entrada será checado contra esta gramática através do programa \ac{RNV} \citep{Sheen2007}. Este programa é sempre chamado automaticamente pelo \emph{Delfine} antes do início da análise para verificar a entrada de dados do usuário, garantindo assim que a execução só será realizada caso exista uma consistência mínima nos dados fornecidos. Na Listagem \ref{lst:arqxmlinput} é apresentado um trecho de um arquivo de entrada típico. Nele pode ser observada a estrutura hierárquica utilizada para o armazenamento dos dados, os quais são tratados de modo completamente modular, ou seja, caso uma análise não precise de determinada informação, o bloco de dados referente a ela pode simplesmente ser deixado de fora do arquivo de dados, sem prejuízo na etapa de pré-processamento.

\begin{listing}[H]
\begin{xmlcode}
<delfine>
    <geometry>
        <mesh dimension="2" order ="1" type="gmsh">
            <filename>HomoIsoBCStruct.msh</filename>
        </mesh>
        <boundary-conditions>
            <well function="inject" id="301">.250</well>
        </boundary-conditions>  
    </geometry>
    <physical>
        <rock-properties>
            <rock-type id="1">
                <porosity>1.0</porosity>
                <permeability type="per-domain">
                    <Kxx>0.50</Kxx>
                    <Kxy>0.0</Kxy>
                    <Kxz>0.0</Kxz>
                </permeability>
            </rock-type>
        </rock-properties>
    </physical>
</delfine>                            
\end{xmlcode}
\caption{Trecho de arquivo de entrada no formato *.xml.}
\label{lst:arqxmlinput}
\end{listing}

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Pre-Process}
\caption{Fluxograma da etapa de pré-processamento.}
\label{fig:preprocessadorflux}
\end{figure}

\section{Processamento}
\label{sc:proc}

Uma vez lidos na etapa de pré-processamento os arquivos necessários para a execução da análise, tem início a etapa de processamento, a qual foi implementada neste trabalho de acordo com os fluxogramas apresentados nas Figs. \ref{fig:ellipticflux} e \ref{fig:hyperbolicflux}.

Considerando uma formulação não-monolítica (i.e. segregada), conforme descrito no capítulo \ref{ch:form_mat}, o fluxograma da Fig.~\ref{fig:ellipticflux} representa os passos necessário para resolver a parte elíptica do problema de escoamentos multifásicos em meios porosos. As formulações matemática e numérica deste problema adotadas neste trabalho podem ser consultadas nas seções \ref{sc:press_eq} e \ref{sc:fem}, respectivamente.

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Elliptic}
\caption{Fluxograma da resolução da parte elíptica.}
\label{fig:ellipticflux}
\end{figure}

A parte parabólica/hiperbólica do problema é descrita pelo fluxograma apresentado na Fig.~\ref{fig:hyperbolicflux}. As formulações matemática e numérica deste problema adotadas neste trabalho podem ser consultadas nas seções \ref{sc:eq_sat} e \ref{sc:supg}, respectivamente.

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Hyperbolic}
\caption{Fluxograma da resolução da parte hiperbólica.}
\label{fig:hyperbolicflux}
\end{figure}

O usuário tem a sua disposição duas alternativas de métodos numéricos para resolução do problema elíptico: o \acf{MEF} e o \acf{MEFM}. As diferenças entre os dois métodos do ponto de vista da formulação numérica são discutidas no capítulo \ref{ch:form_num}, sendo nesta seção discutidos apenas os aspectos de implementação. Já para o problema hiperbólico foi adotado o \ac{MEF} com estabilização via \acf{SUPG}. Todos os métodos foram codificados utilizando a interface na linguagem \emph{Python} da ferramenta \emph{FEniCS/DOLFIN}. A seguir faremos uma descrição geral deste pacote computacional e em seguida mostraremos como o mesmo foi utilizado neste trabalho.

\subsection{FEniCS}
\label{sc:fenics}
O \emph{FEniCS} é um projeto colaborativo em código aberto iniciado em 2003 com o objetivo de automatizar a solução de modelos matemáticos baseados em equações diferenciais \citep{Logg2011}, tendo todos os seus componentes sido desenvolvidos buscando generalidade, eficiência e simplicidade.

De um modo geral, o desenvolvedor tem acesso direto principalmente ao \emph{DOLFIN}, o qual é uma biblioteca que permite a interface com o usuário através de diversas classes acessíveis via programas em \emph{C++} ou em \emph{Python}. Para facilitar a compreensão, a Fig.~\ref{fig:sequencefenics} apresenta de modo esquemático a sequência na qual os diversos componentes do projeto \emph{FEniCS} são executados, e como eles interagem para permitir a resolução do problema.

Inicialmente, o problema tem que ser descrito matematicamente na sua forma variacional (ou fraca). Em seguida, esta deve ser implementada utilizando a \ac{UFL} \citep{Logg2011}, a qual é uma linguagem específica de domínio para declaração da discretização via \ac{MEF} de formas variacionais e funcionais. Para o caso de programas escritos em \emph{Python}, a descrição via \ac{UFL} é embutida dentro do próprio script, já no caso do \emph{C++} é necessário criar um arquivo externo para definição da forma fraca do problema, sendo ele importado para o programa principal.

Em seguida, tais formas são compiladas utilizando o \ac{FFC} \citep{Logg2011}, o qual é o responsável de fato pela geração automática do código otimizado em linguagem de baixo-nível (quando comparada à utilizada para a descrição do problema). Este código estará automaticamente conforme o padrão do \ac{UFC} e pode ser acessado de modo transparente através de classes da biblioteca \emph{DOLFIN}, a qual será responsável pela montagem de todos os tensores necessários para a resolução numérica do problema dentro do programa definido pelo usuário (\emph{Delfine} no caso deste trabalho, como representado na Fig.~\ref{fig:sequencefenics}).

\begin{figure}[hbp]
\centering
\includegraphics[width=0.1\textwidth, angle=270]{chapters/ch04/SequenceFenics}
\caption{Interação entre os diversos componentes do projeto \emph{FEniCS} para definição do problema, seguidos pela resolução no \emph{Delfine} (adaptado de \cite{Rathgeber2010}).}
\label{fig:sequencefenics}
\end{figure}

O \emph{DOLFIN} \citep{Logg2010} automatiza a montagem dos sistemas lineares ou não-lineares provenientes da discretização via \ac{MEF} de \ac{EDP}s expressas na forma variacional.
Na Fig.~\ref{fig:moduledolfin} é apresentada a estrutura modular da biblioteca, onde os dados de entrada fornecidos pelo usuário para um problema específico são a malha, a forma variacional e os tipos de elementos finitos adotados. De posse destes dados, o \emph{DOLFIN} gera as matrizes e vetores necessários para resolução do sistema de equações provenientes da discretização. Como mostrado na figura, o \emph{DOLFIN} contém interfaces para as bibliotecas de álgebra linear computacional \emph{PETSc}, \emph{Epetra}, \emph{uBLAS} e \emph{MTL4}, além de permitir que o usuário utilize um outro programa qualquer, desde que o mesmo tenha suporte para matrizes no formato do \emph{SciPy} \citep{Jones2001}, como é o caso do \emph{PyAMG} usado neste trabalho.

\begin{figure} 
\centering
\includegraphics[width=0.5\textwidth]{chapters/ch04/ModulesDolfin}
\caption{Estrutura modular do \emph{DOLFIN} (retirado de \cite{Logg2010}).}
\label{fig:moduledolfin}
\end{figure}

O \emph{DOLFIN} permite a utilização de alguns operadores básicos na definição da forma variacional, como os de adição (\verb|v+w|), multiplicação (\verb|v*w|), diferenciação (\verb|v.dx(i)|) e integração (\verb|v*dx|). Além disso, e neste ponto reside o grande diferencial desta biblioteca em relação as outras existentes, é possível definir de modo bastante direto operações complexas que nada mais são do que composições dos operadores básicos citados. Entre estas operações podemos citar o produto interno (\verb|dot()|), produto vetorial (\verb|cross()|), divergente (\verb|div()|), gradiente (\verb|grad()|), rotacional (\verb|curl()|), entre outros. 

Portanto, um dos grandes atrativos do \emph{DOLFIN} é a possibilidade de utilizar uma notação muito próxima da matemática para a escrita do código. De modo a exemplificar isto, serão apresentados a seguir os trechos de código correspondentes às formulações do \ac{MEF} de Galerkin, do \ac{MEFM} e do \ac{MEF} com estabilização via \ac{SUPG} discutidos nas seções \ref{sc:fem}, \ref{sc:mfem} e \ref{sc:supg}, respectivamente.

A formulação variacional da equação da pressão utilizando o \ac{MEF} de Galerkin é dada por:
\begin{equation} \label{eq:variational_capImp}
A(p,w) = f(w) \quad \forall w \in W
\end{equation}%
onde as formas bilinear e linear, respectivamente, são:
\begin{equation} \label{eq:bilinearformh2}
A(p,w) = \int_{\Omega} \nabla w \cdot \lambda K \nabla p d \Omega
\end{equation}
\begin{equation} \label{eq:linearformh2}
f(w) = \int_{\Omega} wf d \Omega - \int_{\Gamma} gw d \Gamma
\end{equation}
que representam a notação matemática cuja codificação em \emph{Python} pode ser vista na Listagem \ref{lst:arqpyfem}.
\begin{listing}[H]
\begin{pythoncode}
def Galerkin(self, delfineVar, parameter):
	.
	.      
    # Define variational form
    a = inner(grad(w), K*mob*grad(p))*dx
    L = w*f*dx - g*w*ds
\end{pythoncode}
\caption{Codificação em \emph{Python} da montagem do operador elíptico via \ac{MEF} de Galerkin usando o \emph{FEniCS/DOLFIN}.}
\label{lst:arqpyfem}
\end{listing}

Já a formulação variacional para a equação que resolve simultaneamente a pressão e a velocidade utilizando o \ac{MEFM} é representada pelas seguintes formas bilinear e linear, respectivamente:
\begin{equation} \label{eq:bilinearformhmfem2}
A(p,w,\mathbf{v},\zeta) = \int_{\Omega} \left( K^{-1} \lambda^{-1} \mathbf{v} \cdot \zeta - \nabla \cdot \zeta p - \nabla \cdot \mathbf{v} w \right) d \Omega
\end{equation}
\begin{equation} \label{eq:linearformhmfem2}
f(w) = - \int_{\Omega} fw d \Omega
\end{equation}
que representam a notação matemática cuja codificação em \emph{Python} pode ser vista na Listagem \ref{lst:arqpymfem}.
\begin{listing}[H]
\begin{pythoncode}
def MixedFEM(self, delfineVar, parameter):
	.
	.  
    # Define variational form
    a = (dot((invK/mob)*v, zeta)
        - div(zeta)*p - div(v)*w)*dx
    L = - f*w*dx
\end{pythoncode}
\caption{Codificação em \emph{Python} da montagem do operador elíptico via \ac{MEFM} usando o \emph{FEniCS/DOLFIN}.}
\label{lst:arqpymfem}
\end{listing}

A formulação variacional para a equação da saturação utilizando o \ac{MEF} com estabilização via \ac{SUPG} e termo de captura de choque para adição de difusão artificial é representada matematicamente da seguinte forma:
\begin{equation} \label{eq:bilinearformhsupg2}
\begin{array}{cc}
F(S,w) = \int_{\Omega} \left( w \phi \frac{S^{n+1} - S^{n}}{\Delta t} \right) d \Omega + 
\int_{\Omega} wf_{,S}\mathbf{v}^{n+1} \cdot \nabla S^{n+1} d \Omega +
\sum\limits_{E_{i}} \int_{E_{i}} \left(\mathbf{v}^{n+1} \cdot \nabla w \right) \tau_{s} r^{n+1} d \Omega + \\ 
\sum\limits_{E_{i}} \int_{E_{i}} \nu_{shock} \nabla w \cdot \nabla S^{n+1} d \Omega
\end{array}
\end{equation}
onde
\begin{equation} \label{eq:residuumsupg2}
r^{n+1} = \phi \frac{S^{n+1} - S^{n}}{\Delta t}+ 
          f_{,S}\mathbf{v}^{n+1} \cdot \nabla S^{n+1}
\end{equation}
com
\begin{equation} \label{eq:stabtermsupg2}
\tau_{s} = \frac{h}{2 \left| \left| \mathbf{v}^{n+1} \right| \right| }
\end{equation}
e
\begin{equation} \label{eq:viscartterm2implem}
\nu_{shock} = \left\{ \begin{array}{ll}
  \frac{\beta h \vert r^{n+1} \vert}{2\vert\vert \nabla S^{n} \vert\vert} & \textrm{se $\vert\vert \nabla S^{n} \vert\vert \neq 0$}\\
  0 & \textrm{caso contrário}
  \end{array} \right.
\end{equation}
A codificação em \emph{Python} deste método pode ser vista na Listagem \ref{lst:arqpysupg}.
\begin{listing}[H]
\begin{pythoncode}
def SUPG(self, delfineVar, parameter):
	.
	.      
    # Galerkin variational problem
    F = w*phi*((S-S0)/dt)*dx +
        (w*fs*dot(v, grad(S))*dx
    # Residual
    r = phi*((S-S0)/dt) + fs*(dot(v, grad(S)))
    # SUPG stabilization term
    tau = h/(2.0*sqrt(dot(v, v)))
    F += tau*dot(v, grad(w))*r*dx
    # Add shock capturing term
    beta = 2.0
    snorm = sqrt(dot(grad(S0), grad(S0)))
    tol = 1E-15
    if (abs(snorm) > tol):
        vshock = (beta*h*abs(r))/(2*snorm)
    else:
        vshock = 0.0
    F += vshock*dot(grad(w), grad(S))*dx
    # Create bilinear and linear forms
    a = lhs(F)
    L = rhs(F)
\end{pythoncode}
\caption{Codificação em \emph{Python} da montagem do operador hiperbólico via \ac{MEF} com estabilização via \ac{SUPG} usando o \emph{FEniCS/DOLFIN}.}
\label{lst:arqpysupg}
\end{listing}

Como pôde ser visto, o \emph{DOLFIN} permite tanto a definição direta das formas bilineares e lineares, quanto a definição de um funcional e posterior subdivisão dele através dos comandos \verb|rhs()| e \verb|lhs()|. Uma vez obtidas as formas que descrevem o problema, o sistema de equações é montado através de um simples comando, como exemplificado na Listagem \ref{lst:assembly}.

\begin{listing}[H]
\begin{pythoncode}
    # Assemble system
    A, rhs = assemble_system(a, L)
    bc.apply(A, rhs)
\end{pythoncode}
\caption{Montagem do sistema de equações no formato matricial e aplicação das condições de contorno usando o \emph{FEniCS/DOLFIN}.}
\label{lst:assembly}
\end{listing}

Para a resolução do sistema de equações proveniente das matrizes e vetores resultantes da discretização foram utilizadas as bibliotecas de álgebra linear \emph{PyAMG} (prioritariamente) e \emph{uBLAS} (para matrizes provenientes do \ac{MEFM}). Como já mencionado, a interface desta última biblioteca com o \emph{DOLFIN} é implementada por default, logo o foco neste capítulo será na interface com o \emph{PyAMG}, o qual é descrito com mais detalhes na seção a seguir.

\subsection{PyAMG}
\label{sc:pyamg}

O \emph{PyAMG} \citep{Bell2008} é uma coleção de resolvedores de equações lineares com uma interface em \emph{Python}. Diversas variações do método \ac{AMG} estão implementadas no \emph{PyAMG}, como o \ac{AMG} clássico, o \emph{smoothed aggregation} (SA) e o \emph{adaptive smoothed aggregation}. Por ter sido escrito de maneira modular, o \emph{PyAMG} se apresenta como uma excelente ferramenta para prototipagem rápida de métodos multigrid. Além disso, por ter suas operações de maior custo computacional compiladas em \emph{C++} é possível a resolução eficiente de problemas de grande escala.

A listagem de código \ref{lst:pyamg} apresenta um exemplo típico de utilização do \emph{PyAMG} em conjunto com o \emph{DOLFIN}. A comunicação das matrizes e vetores provenientes da montagem no \emph{DOLFIN} é feita através do formato \emph{SciPy}. Em seguida, tais dados são repassados em conjunto com alguns parâmetros numéricos para a função do \emph{PyAMG} responsável pela resolução do sistema de equações. No exemplo mostrado, se utilizou um resolvedor do tipo \ac{CG} com precondicionamento via \ac{AMG}. Os parâmetros passados foram o número máximo de níveis menos refinados (ver seção \ref{sc:multigrid} para mais detalhes) e a tolerância considerada. A grande vantagem do uso desta biblioteca é justamente a possibilidade de testar diversas possibilidades apenas com a mudança destes parâmetros de entrada, já que seria perfeitamente possível trocar o resolvedor do tipo \ac{CG} para um \ac{GMRES}, caso se esteja trabalhando com matrizes não-simétricas. Outra flexibilidade permitida é a de alterar o tipo de ciclo multigrid utilizado, sendo o tipo $V$ considerado default caso nenhuma informação seja fornecida, como no caso do exemplo utilizado.

\begin{listing}[H]
\begin{pythoncode}
def solve_withPyAMG(self, delfineVar, parameter):
    # Getting data from elliptic eq. assembler
    A = delfineVar.A
    rhs = delfineVar.rhs
    # Get sparse matrix data
    (r,c,data) = A.data()
    n = A.size(0)
    # Matrix in scipy/numpy format
    As = csr_matrix((data,c.view(),r.view()),shape=(n,n))
    # Get right-hand side vector(rhs) data
    b = rhs.data()
    res = []
    # Solve with AMG as preconditionar for the CG Method
    ml = smoothed_aggregation_solver(Asp,max_coarse=10)
    x = ml.solve(b,tol=1e-10,accel='cg',residuals=res)
\end{pythoncode}
\caption{Leitura da matriz e vetor que representam o sistema de equações e resolução do mesmo utilizando o \emph{PyAMG}.}
\label{lst:pyamg}
\end{listing}

\section{Pós-Processamento}
\label{sc:pos-proc}

Uma vez finalizada a etapa de processamento, é necessário analisar os resultados obtidos. Em termos de implementação computacional esta é a fase que envolve menos componentes, como pode ser visto na Fig.~\ref{fig:posprocessadorflux}.

O \emph{DOLFIN} dispões de funções para impressão em formato \ac{XML} dos dados armazenados (como malhas, propriedades, etc.) e resultados gerados durante a análise. Esta funcionalidade pode ser utilizada de modo bastante direto no programa devido ao uso de operadores sobrecarregados. A Listagem \ref{lst:satoutput} apresenta um exemplo de impressão do campo de saturação $S$ em um passo de tempo $t$. O formato utilizado (\verb|.vtk|) nada mais é do que um arquivo \ac{XML} formatado para seguir um padrão definido que pode ser lido por vários programas de visulaziação. Neste trabalho foi utilizado prioritariamente o \emph{Paraview} \citep{Henderson2007}, porém o arquivo também poderia ter sido visualizado em outros programas de visualização, como o \emph{VisIt} ou o \emph{TecPlot}. Além disso, o \emph{DOLFIN} permite a visualização rápida de resultados durante a própria simulação utilizando uma ferramenta própria chamada \emph{Viper}.

\begin{listing}[H]
\begin{pythoncode}
    # Output file
    out_file = File("Results/supg_saturation.vtk")
    # Save the saturation solution to file
    out_file << (S, t)
\end{pythoncode}
\caption{Impressão dos resultados em arquivos do tipo \ac{XML} usando o \emph{FEniCS/DOLFIN}.}
\label{lst:satoutput}
\end{listing}

Além da impressão dos arquivos com os resultados associados aos campos de pressão, velocidade e saturação, foi implementado neste trabalho um script em \emph{Python} para comparação da performance de diversos métodos de resolução do sistema de equações (\ac{AMG}, \ac{CG}, \ac{GMRES}, \ac{AMG}+\ac{CG} e \ac{AMG}+\ac{GMRES}). Este script lê automaticamente todos os resíduos gerados pelos métodos desejados e cria gráficos semi-logarítmicos para visualização da evolução do resíduo em comparação ao número de iterações.

\begin{figure} 
\centering
\includegraphics[width=0.7\textwidth]{chapters/ch04/Pos-Process}
\caption{Fluxograma da etapa de pós-processamento.}
\label{fig:posprocessadorflux}
\end{figure}