\chapter{Implementação Computacional}
\label{ch:implementacao}

Todas as formulações, tanto matemática quanto numéricas, utilizadas neste trabalho apresentam grandes desafios, não apenas no que tange a compreensão teórica, mas também em relação ao desenvolvimento propriamente dito do software, já que é de fundamental importância uma implementação adequada destes métodos a fim de se atingir um compromisso vantajoso entre generalidade e performance computacional, pois este dois objetivos frequentemente tendem a conduzir as diretivas de codificação do programa para direções diferentes.

Este capítulo se propõe a apresentar o modo como o programa de computador resultante deste trabalho foi elaborado, sendo que para isto foi adotada uma descrição \emph{top-down}, ou seja, primeiramente são expostas as características gerais do programa e em seguida as divisões do mesmo em diferentes blocos que permitem uma melhor abordagem do problema. Cada um destes blocos é então subdivido em partes menores, as quais correspondem a tarefas específicas, que podem ter suas soluções diretamente codificadas utilizando uma linguagem de programação ou então serem resolvidas através de alguma biblioteca de software disponível na internet.

Outro aspecto a ser comentado a respeito da filosofia de desenvolvimento do programa é justamente que se buscou sempre utilizar soluções já prontas disponíveis publicamente, de modo a evitar o fenômeno popularmente conhecido como "reinventar a roda". Além disso, foi dada preferência explícita a pacotes publicados segundo licenças livres (e.g., GNU GPL, BSD License, etc.), as quais permitem o uso, estudo, adaptação e redistribuição de programas de modo bastante transparente. Logicamente, o resultado deste trabalho também está disponível através de uma licença livre. No Apêndice \ref{ch:manual} se encontra um manual com instruções para a obtenção, instalação e uso do software desenvolvido.

\section{Estrutura Geral do Programa}
\label{sc:est_prog}
A resolução de um problema através de um método numérico pode normalmente ser dividida em três etapas distintas:
\begin{itemize}
\item \emph{Pré-processamento}: Definição de uma geometria que aproxime o domínio real e geração de uma malha de pontos discretos para a mesma. Além disso, nesta etapa são fornecidas as condições de contorno e propriedades que buscam representar o problema real. Também nesta fase são definidos os parâmetros da análise efetuada no passo a seguir.
\item \emph{Processamento}: Cálculo propriamente dito dos valores para as variáveis de interesse. Para isto, é utilizada alguma formulação numérica específica que trate adequadamente a descrição matemática do problema. Os resultados obtidos nesta etapa são analisados criticamente na fase seguinte.
\item \emph{Pós-processamento}: Visualização e interpretação dos resultados fornecidos pela etapa de processamento. Caso a resposta obtida seja satisfatória, a resolução do problema é encerrada neste ponto. Caso contrário, alterações são feitas na etapa de pré-processamento e o ciclo é reiniciado até que se atinja o objetivo.
\end{itemize}

Esta divisão também foi considerada no desenvolvimento do \emph{Delfine}, sendo este o nome do programa desenvolvido neste trabalho. Os blocos responsáveis por executar cada uma das tarefas descritas anteriormente serão apresentados na forma de fluxograma e detalhados nas seções seguintes. 

\section{Pré-Processamento}
\label{sc:pre-proc}

Na Fig. \ref{fig:preprocessadorflux} pode ser visto um fluxograma representando os vários passo necessários para a obtenção, a partir de um problema real, de um problema discreto passível de ser analisado numericamente.

Inicialmente, é necessário por parte do usuário ter uma descrição o mais precisa possível do problema de interesse. De posse da mesma, parte-se para as etapas de discretização da geometria (i.e., geração da malha) e de definição de uma arquivo de entrada de dados.

O \emph{Delfine} oferece três caminhos para a obtenção da malha: através de um gerador interno do \emph{FEniCS/Dolfin}, o qual é utilizado principalmente na parte de processamento, porém disponibiliza algumas rotinas básicas de geração de malhas, com a vantagem de tornar o programa independente de qualquer programa externo para este fim, já que os parâmetros para definição de malha são definidos no próprio arquivo de entrada de dados da simulação. Porém, como grande desvantagem podemos citar o fato da limitação quanto às geometrias disponíveis, pois apenas formas primitivas como linhas, retângulos, círculos, paralelepípedos e esferas podem ser descritos usando esta ferramenta.

Uma segunda alternativa é o uso da ferramenta \emph{Gmsh} \citep{Geuzaine2009}, a qual apresenta como vantagem uma maior flexibilidade na definição da geometria, pois este gerador disponibiliza várias operações que podem ser executadas em formas primitivas para a obtenção de outras mais complexas. Entre estas operações podemos citar adição, subtração, extrusão, escalonamento, divisão, entre outras. Além disso, o \emph{Gmsh} dispõe de uma meta-linguagem própria que possibilita a escrita de scripts para a automatização e parametrização da geração de malhas. Como desvantagem, temos a necessidade de conversão do arquivo no formato *.msh gerado pelo \emph{Gmsh} para o padrão utilizado pelo \emph{Delfine}, o qual é derivado diretamente do formato utilizado pelo \emph{FEniCS/Dolfin}. Esta conversão é feita utilizando o script \emph{delfine-convert}.

% Arrumar citacao para todos os programas abaixo.
Como terceira e última alternativa temos o uso de outros gerador de malhas disponíveis publicamente ou não, como por exemplo o \emph{Triangle}, o \emph{Medit}, o \emph{ExodusII} ou o pré-processador do \emph{Abaqus}. Como vantagem desta alternativa podemos citar a liberdade em relação ao tipo de gerador de malhas a ser utilizado, já que o usuário pode escolher aquele com o qual tem mais familiaridade. Porém, os arquivos nos formatos de saída de qualquer um dos programas citados terá que ser convertido para o formato padrão do \emph{Delfine} utilizando o script \emph{dolfin-convert} \citep{Logg2010}.

A diferença básica entre a segunda e a terceira alternativas reside exatamente no tipo de script utilizado para a conversão dos arquivos de malha. O \emph{dolfin-convert} é disponibilizado como parte da família de pacotes \emph{FEniCS/Dolfin}, porém o mesmo faz apenas uma conversão das informações geométricas e topológicas da malha, ignorando às informações extras eventualmente presentes nos arquivos. Logo, não é possível importar \emph{flags} de condições de contorno definidos no \emph{Triangle} diretamente no \emph{Delfine}, por exemplo. Sendo assim, tais informações têm que ser adicionadas manualmente aos arquivos de entrada do \emph{Delfine}.

Já o \emph{delfine-convert} é uma adaptação do \emph{dolfin-convert} realizada durante este trabalho com o objetivo de importar todas as indicações de condições de contorno definidas no \emph{Gmsh} e exportá-las no formato lido pelo \emph{Delfine}. Esta funcionalidade é de fundamental importância para problemas de maior complexidade, pois permite agilizar bastante a etapa de pré-processamento. Por isto, dentre toda as citadas, a segunda alternativa foi a mais utilizada ao longo deste trabalho.

Uma vez obtida a geometria discretizada, é necessário ler o arquivo de entrada de dados, o qual contém informações a respeito das condições de contorno, propriedades de rochas e fluidos, parâmetros numéricos, etc. De um modo geral, tais informações podem ser fornecidas através de um arquivo de texto comum, desde que as mesmas estejam ordenadas de modo estruturado para serem processadas pelo programa.

Entretanto, tal abordagem não apresenta uma robustez adequada, pois permite que pequenos erros do usuário na confecção do arquivo de dados passem desapercebidos, o que pode acarretar tanto em demora para executar uma análise inicial, pois se torna necessário uma checagem manual de todos os parâmetros fornecidos até se encontrar a fonte de erro, como também se permite executar análises com valores não consistentes, os quais podem vir a gerar resultados totalmente não-físicos, podendo inclusivo levar o usuário a interpretar o fenômeno de interesse de maneira errônea.

Sendo assim, de modo a aumentar a robustez da entrada de dados se optou pelo uso de arquivos estruturados no formato \ac{XML} \citep{Bray2000} com a utilização da linguagem de especificação de esquemas \ac{RNC} \citep{Clark2001}. Esta linguagem permite definir um padrão lógico a ser seguido por qualquer arquivo \ac{XML} gerado, caso contrário o mesmo não é considerado válido e o ponto exato onde o erro na entrada de dados foi encontrado é apresentado ao usuário antes mesmo de qualquer análise ter início. Este padrão é definido através de um arquivo chamado de \emph{Schema Grammar} e todo arquivo de entrada será checado contra esta gramática através do programa \ac{RNV} \citep{Sheen2007}. Este programa é sempre chamado automaticamente pelo \emph{Delfine} antes do início da análise para verificar a entrada de dados do usuário, garantindo assim que a execução só será realizado caso exista uma consistência mínima nos dados fornecidos. Na Fig. \ref{fig:arqxmlinput} é apresentado um trecho de um arquivo de entrada típico.

\begin{listing}[H]
\begin{xmlcode}
<delfine>
    <geometry>
        <mesh dimension="2" order ="1" type="gmsh">
            <filename>HomoIsoBCStruct.msh</filename>
        </mesh>
        <boundary-conditions>
            <well function="inject" id="301">.250</well>
        </boundary-conditions>  
    </geometry>
    <physical>
        <rock-properties>
            <rock-type id="1">
                <porosity>1.0</porosity>
                <permeability type="per-domain">
                    <Kxx>0.50</Kxx>
                    <Kxy>0.0</Kxy>
                    <Kxz>0.0</Kxz>
                </permeability>
            </rock-type>
        </rock-properties>
    </physical>
</delfine>                            
\end{xmlcode}
\caption{Trecho de arquivo de entrada no formato *.xml.}
\label{lst:arqxmlinput}
\end{listing}

\begin{listing}[H]
\begin{pythoncode}
def MixedFEM(self, delfineVar, parameter):
	.
	.
	.      
	# Define variational form
	a = (dot((invK/mob)*sigma, tau)
		- div(tau)*u - div(sigma)*v)*dx
	L = - f*v*dx
\end{pythoncode}
\caption{Montagem do operador diferencial elíptico via \ac{MEFM}.}
\label{lst:arqpymfem}
\end{listing}

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Pre-Process}
\caption{Fluxograma da etapa de pré-processamento.}
\label{fig:preprocessadorflux}
\end{figure}

\section{Processamento}
\label{sc:proc}

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Elliptic}
\caption{Fluxograma da resolução da parte elíptica.}
\label{fig:ellipticflux}
\end{figure}

\begin{figure} 
\centering
\includegraphics[width=1.0\textwidth]{chapters/ch04/Hyperbolic}
\caption{Fluxograma da resolução da parte hiperbólica.}
\label{fig:hyperbolicflux}
\end{figure}

\section{Pós-Processamento}
\label{sc:pos-proc}

\begin{figure} 
\centering
\includegraphics[width=0.7\textwidth]{chapters/ch04/Pos-Process}
\caption{Fluxograma da etapa de pós-processamento.}
\label{fig:posprocessadorflux}
\end{figure}