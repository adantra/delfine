\chapter{Delfine - Manual do usuário}
\label{ch:manual}

Ao longo desta dissertação foi discutido todo o arcabouço matemático, numérico e computacional necessário para a obtenção dos resultados apresentados. Entretanto, como comentado no Cap.~\ref{ch:implementacao}, todo este trabalho só foi possível de ser realizado graças às inúmeras ferramentas computacionais disponibilizadas publicamente na internet através de licenças livres. Sendo assim, este apêndice tem o objetivo de servir como manual prático para obtenção e uso do programa desenvolvido, na esperança de que possa ser mais útil para outrem e assim fornecer uma pequena contribuição à comunidade.

\section{Dependências e \emph{Download} do Programa}
\label{sc:instalacao}
O \emph{software} foi todo desenvolvido na distribuição \emph{Ubuntu 10.04} do sistema operacional \emph{GNU/Linux}, logo a descrição do procedimento de instalação e uso do programa será focada neste ambiente. Em todo caso, os comandos e pacotes aqui descritos podem ser executados ou instalados com alterações mínimas em qualquer outra distribuição recente do \emph{GNU/Linux}.

Para uso do \emph{Delfine} é necessário que alguns programas já estejam instalados no sistema. A lista a seguir indica quais são estes pré-requisitos e onde eles podem ser obtidos. Obviamente, qualquer programa gerenciador de pacotes (\emph{apt-get}, \emph{rpm}, etc.) pode ser utilizado para agilizar o processo de instalação deles.
\begin{itemize}
\item \emph{FEniCS} (\url{www.fenicsproject.org}): Biblioteca para automação da solução de \ac{EDP}s. O \emph{DOLFIN} é parte integrante dela.
\item \emph{Python 2.x} (\url{www.python.org}): Linguagem de programação interpretada utilizada neste trabalho.
\item \emph{SciPy} (\url{www.scipy.org}): Biblioteca para computação científica em \emph{Python}.
\item \emph{PyAMG} (\url{www.code.google.com/p/pyamg}): Biblioteca de resolvedores \ac{AMG} com interface para \emph{Python}.
\item \emph{RNV} (\url{www.davidashen.net/rnv.html}): Validador de arquivos \emph{XML}.
\end{itemize}

Além destas dependências, os programas listados a seguir foram usados ao longo deste trabalho em conjunto com o \emph{Delfine} para a geração dos modelos e análise dos resultados obtidos, logo recomenda-se a instalação e uso deles.
\begin{itemize}
\item \emph{Gmsh} (\url{www.geuz.org/gmsh}): Programa para geração de malhas estruturadas e não-estruturadas em 2 ou 3 dimensões.
\item \emph{Paraview} (\url{www.paraview.org}): Programa para visualização dos resultados.
\item \emph{Matplotlib} (\url{http://matplotlib.sourceforge.net/}): Biblioteca para geração de gráficos.
\end{itemize}

O próximo passo é a obtenção do código-fonte do \emph{Delfine}. O serviço de hospedagem de projetos da Google (\emph{Google Codes}) foi utilizado em conjunto com o sistema de controle de versão \emph{Apache Subversion} para gerenciamento do código. Na página deste projeto na internet (\url{http://code.google.com/p/delfine}) estão disponíveis, além do código em si, vários documentos, como a versão digital desta dissertação, artigos e apresentações utilizados em congressos, entre outros. A seguir é mostrado o comando a ser digitado no terminal em uma pasta qualquer para baixar a versão mais recente do programa.
\begin{listing}[H]
\begin{bashcode}
$ svn checkout http://delfine.googlecode.com/\
svn/trunk/delfine
\end{bashcode}
\caption{\emph{Download} do programa a partir de repositório \emph{svn}.}
\label{lst:checkout}
\end{listing} %$

\section{Dados de Entrada}
\label{sc:entrada}
O programa é executado a partir da linha de comando utilizando o script \verb|run.py|, o qual se encontra na pasta-raiz \verb|Delfine|. O comando necessário para executar uma análise é apresentado a seguir, onde ``caseName'' deve ser substituído pelo nome do arquivo de dados considerado.
\begin{listing}[H]
\begin{bashcode}
$ ./run.py 'caseName'
\end{bashcode}
\caption{Execução do programa a partir do terminal.}
\label{lst:execucao}
\end{listing} %$

Uma vez solicitada a execução do programa, são necessários dois arquivos de entrada, um com os dados da análise e descrição do problema em si e outro com as informações da malha (existe uma exceção para este caso, a qual será discutida adiante). No diretório para o qual o programa foi baixado existe uma pasta chamada \verb|Delfine/CaseFiles|, dentro da qual existem alguns arquivos que podem ser usados como base para a criação de outros modelos. Descreveremos a seguir como estes dois arquivos devem ser gerados.

\subsection{Arquivo de Dados}
\label{sc:dados}
As informações necessárias para a análise encontram-se neste arquivo subdivididas em três grupos:

\emph{Geometry}: Neste grupo é informado para o programa qual a malha que será considerada. Além disso, são fornecidas neste grupo as condições de contorno que descrevem o problema. Um modelo para este grupo pode ser visto na listagem a seguir:
\begin{listing}[H]
\begin{xmlcode}
<geometry>
   <mesh dimension="2" order ="1" type="gmsh">
       <filename>malha.msh</filename>
   </mesh>
   <boundary-conditions>
       <well function="injection" id="1">1.0</well>
       <well function="production" id="2">-1.0</well>
   </boundary-conditions>  
</geometry>
\end{xmlcode}
\caption{Grupo \emph{Geometry}.}
\label{lst:arqmalhaxml}
\end{listing} %$

O tipo de malha é escolhido através do parâmetro \verb|type|, o qual pode ser definido como: \verb|gmsh|, caso a malha tenha sido gerada externamente por este programa, sendo que neste caso ela será automaticamente convertida para o formato \verb|*.xml| pelo script \emph{delfine-convert} considerando os indicadores de condição de contorno fornecidos; \verb|xml|, caso a malha tenha sido gerado por outro programa (\emph{Triangle}, \emph{Medit}, \emph{ExodusII}, etc.) e convertida manualmente pelo script \emph{delfine-convert}; ou \verb|dolfin-generated|, caso a malha seja criada utilizando o gerador interno do \emph{DOLFIN}. Neste último caso, as opções de malha são definidas usando os seguintes parâmetros:
\begin{listing}[H]
\begin{xmlcode}
<geometry>
   <mesh dimension="2" type="dolfin-generated">
      <dolfin-generated type="UnitSquare" nx="8" ny="8"/>
   <subdomains quantity="1"/>
   </mesh>
.
.
</geometry>
\end{xmlcode}
\caption{Definição de malha a ser gerada pelo \emph{DOLFIN}.}
\label{lst:arqmalhaxml2}
\end{listing} %$

Apenas geometrias simples podem ser geradas com esta opção, sendo que as alternativas são as seguintes: \verb|UnitSquare| (para domínios bidimensionais com \verb|nx|$\times$\verb|ny| elementos), \verb|UnitInterval| (para domínios unidimensionais com \verb|nx| elementos), \verb|UnitCube| (para domínios tridimensionais com \verb|nx|$\times$\verb|ny|$\times$\verb|nz| elementos) e \verb|UnitCircle| (para domínios bidimensionais com \verb|nr| elementos na direção radial) .

Por fim, para cada poço existente no domínio deve ser escrita uma linha no subgrupo \verb|boundary-conditions| contendo o tipo de poço (injeção ou produção), o identificador dele (correspondente ao definido durante a geração da malha) e o valor do fluxo total prescrito. No momento estas condições ainda são bastante restritivas, por isso um dos objetivos para o futuro é adicionar modelos de poços mais gerais e realistas.

\emph{Physical}: Neste grupo são descritas as propriedades das rochas, dos fluidos e de interação rocha-fluido. É importante ressaltar que alguns dos parâmetros existentes no arquivo de dados são referentes a funcionalidades ainda não implementadas. A viscosidade e densidade de fluidos, por exemplo, são normalmente consideradas dependentes da temperatura e pressão, respectivamente, mas nesse momento são ainda definidas com valores constantes, por isto se utilizou a opção \verb|model="none"| no arquivo de dados. O mesmo comentário vale para a porosidade da rocha. Um modelo para este grupo pode ser visto na listagem a seguir:
\begin{listing}[H]
\begin{xmlcode}
<physical>
   <fluid-properties>
       <water use="no">
           <viscosity model="yes">1.0</viscosity>
       </water>
       <oil use="yes">
           <viscosity model="none">1.0</viscosity>
       </oil>
   </fluid-properties>
   <rock-properties>
       <rock-type id="1">
           <porosity compressible="no">1.0</porosity>
           <permeability type="per-domain">
               <Kxx>1</Kxx>
               <Kxy>0.0</Kxy>
               <Kyy>1</Kyy>
           </permeability>
       </rock-type>
   </rock-properties>
   <rock-fluid-properties>
       <relative-permeability model="corey">
           <krw>
               <krw_end>1.0</krw_end>
               <Swc>0.0</Swc>
               <nw>2.0</nw>
           </krw>
           <kro>
               <Sor>0.0</Sor>
               <no>2.0</no>
           </kro>
       </relative-permeability>
   </rock-fluid-properties>
</physical>
\end{xmlcode}
\caption{Grupo \emph{Physical}.}
\label{lst:arqphysxml}
\end{listing} %$

Em relação às propriedades das rochas, deve ser adicionado um subgrupo do tipo \verb|rock-properties| com uma número de identificação correspondente ao de cada um dos subdomínios definidos no arquivo de malha. O tensor de permeabilidade pode ser expandido ou reduzido de acordo com o número de dimensões do problema. Para um caso tridimensional, por exemplo, bastaria adicionar linhas para os valores de \verb|Kxz| e \verb|Kzz|.

\emph{Numerical}: Neste grupo são descritos os parâmetros de análise utilizados para a simulação numérica do problema. A seguir é apresentado um exemplo com as principais opções:
\begin{listing}[H]
\begin{xmlcode}
<numerical>
   <pressure-solver formulation="galerkin" type="cg">
       <tolerance>1e-10</tolerance>
       <max-number-steps>1000</max-number-steps>
       <pre-conditioning type="amg">
           <number-coarse-levels>5</number-coarse-levels>
       </pre-conditioning>
   </pressure-solver>
   <saturation-solver>
       <total-time-analysis>200</total-time-analysis>            
       <courant>0.9</courant>
       <limiter type="none"/>
   </saturation-solver>
</numerical>
\end{xmlcode}
\caption{Grupo \emph{Numerical}.}
\label{lst:arqnuxml}
\end{listing} %$

O primeiro subgrupo (\verb|pressure-solver|) pode receber as formulações \verb|galerkin| ou \verb|mixedfem| (ver Cap. \ref{ch:form_num} para detalhes sobre as características de cada uma) e os tipos \verb|cg| (Método dos Gradientes Conjugados (CG)), \verb|gmres| (Método do Resíduo Mínimo Generalizado (GMRES)) ou \verb|none|, sendo que neste último caso o \ac{AMG} é utilizado isoladamente. Já o subgrupo \verb|pre-conditioning| pode ser do tipo \verb|amg| ou \verb|none|, sendo que neste caso deve obrigatoriamente ser escolhido algum tipo de resolvedor em \verb|pressure-solver|. Devido à disponibilidade de vários métodos iterativos dentro da biblioteca \emph{PyAMG}, espera-se em breve adicionar novas opções de resolvedores iterativos e diretos.

As opções para o parâmetro \verb|limiter| são: \verb|SUPG| (ou seja, apenas o termo de estabilização), \verb|SUPG+Wells| (estabilização via \ac{SUPG} e adição de difusão artificial) e \verb|none| (\ac{MEF} de Galerkin aplicado diretamente para a equação hiperbólica). Em relação ao tipo de limitador para captura de choque, até o momento apenas o termo de difusão artificial isotrópica sugerido por \cite{Wells2008} está disponível, porém um dos trabalhos futuros (ver Seção \ref{sc:trabFuturos}) é exatamente a adição de difusão artificial anisotrópica conforme proposto por \cite{Codina1992}.

\subsection{Arquivo de Malha}
\label{sc:malha}

Existe a opção de ter a malha gerada pelo próprio \emph{DOLFIN} ou então usar um gerador externo e convertê-la utilizando um \emph{script}. No primeiro caso não é necessário fornecer um arquivo, já na segunda alternativa a malha é descrita através de uma arquivo do tipo \verb|*.xml|, o qual contém as informações referentes aos nós, elementos e \emph{flags} indicadores de domínio ou condição de contorno. A estrutura geral do arquivo é conforme o exemplo a seguir:
\begin{listing}[H]
\begin{xmlcode}
<dolfin xmlns:dolfin="http://www.fenicsproject.org">
  <mesh celltype="triangle" dim="2">
    <vertices size="25">
      <vertex index="0" x="0" y="0"/>
      <vertex index="1" x="0" y="1"/>
      .
      .
    </vertices>
    <cells size="32">
      <triangle index="0" v0="0" v1="4" v2="18"/>
      <triangle index="1" v0="4" v1="17" v2="18"/>
      .
      .
    </cells>
  </mesh>
</dolfin>
\end{xmlcode}
\caption{Arquivo de malha.}
\label{lst:geomxml}
\end{listing} %$

\section{Exemplo Detalhado}
\label{sc:exemplo}
Nesta seção, apresentaremos a construção detalhada de um exemplo utilizado neste trabalho de modo a consolidar todas as informações apresentadas nas seções anteriores deste manual. Os dados do problema que serão utilizados para a geração do arquivo de dados são apresentados no capítulo de resultados na Seção \ref{sc:quarterfivespothetero}.

Este problema trata da solução do escoamento em meios porosos em um domínio heterogêneo representado por um quadrado unitário com uma região de baixa permeabilidade no seu interior, sendo portanto uma geometria bastante simples. Mesmo assim, iremos considerar o uso do \emph{Gmsh} para a geração desta malha devido à existência dos 2 subdomínios. Detalhes sobre o uso da interface gráfica do \emph{Gmsh} para se gerar interativamente a geometria podem ser encontrados na página do programa citada na Seção \ref{sc:instalacao}. Uma vez criada a geometria na interface, o \emph{Gmsh} salva as informações em um arquivo do tipo \verb|*.geo|, o qual é utilizado para gerar a malha em si.

O arquivo de malha (\verb|*.msh|) pode ser obtido executando o seguinte comando em um terminal:

\begin{listing}[H]
\begin{bashcode}
$ gmsh file.geo
\end{bashcode}
\caption{Geração da malha usando o \emph{Gmsh} a partir de um arquivo de geometria.}
\label{lst:geramalha}
\end{listing} %$

Além das informações geométricas (coordenadas dos pontos, linhas que formam os contornos, etc.), são fornecidos no arquivo de geometria os identificadores (\emph{flags}) de subdomínio e de condições de contorno (p.ex., poços), os quais são indicados pelos comandos \verb|Physical Surface| e \verb|Physical Point|, respectivamente. O arquivo do tipo \verb|*.geo| usado para gerar a geometria desejada para este exemplo é descrito na listagem a seguir: 

\begin{listing}[H]
\begin{bashcode}
Point(1) = {0, 0, 0, 0.05};
Point(2) = {0, 1, 0, 0.05};
Point(3) = {1, 0, 0, 0.05};
Point(4) = {1, 1, 0, 0.05};
Point(5) = {0.25, 0.25, 0, 0.05};
Point(6) = {0.25, 0.75, 0, 0.05};
Point(7) = {0.75, 0.25, 0, 0.05};
Point(8) = {0.75, 0.75, 0, 0.05};
Line(1) = {1, 3};
Line(2) = {3, 4};
Line(3) = {4, 2};
Line(4) = {2, 1};
Line(5) = {5, 7};
Line(6) = {7, 8};
Line(7) = {8, 6};
Line(8) = {6, 5};

Line Loop(352) = {7, 8, 5, 6};
Plane Surface(352) = {352};

Line Loop(353) = {3, 4, 1, 2, -6, -5, -8, -7};
Plane Surface(353) = {353};

Physical Surface(352) = {352};
Physical Surface(353) = {353};

Physical Point(301) = {1};
Physical Point(351) = {4};
\end{bashcode}
\caption{Arquivo de geometria.}
\label{lst:arqgeo}
\end{listing} %$

Em seguida, é criado um arquivo de dados para o problema. Inicialmente, precisamos fornecer os dados relativos ao grupo \emph{Geometry}, conforme descrito na Seção \ref{sc:dados}. Para este caso, definimos o tipo de malha como \verb|gmsh-generated|, a dimensão como $2$, e o nome do arquivo como \verb|exemplo_heterogeneo.msh|. As condições de contorno são os poços de injeção e produção, os quais recebem os identificadores definidos no arquivo de geometria ($301$ para injeção e $351$ para produção). Para isto, definimos os parâmetros \verb|function| e \verb|id|. Assim, este primeiro trecho do arquivo de dados deve ter a seguinte aparência:
\begin{listing}[H]
\begin{xmlcode}
<geometry>
   <mesh dimension="2" order ="1" type="gmsh">
       <filename>exemplo_heterogeneo.msh</filename>
   </mesh>
   <boundary-conditions>
       <well function="injection" id="301">0.25</well>
       <well function="production" id="351">-0.25</well>
   </boundary-conditions>  
</geometry>
\end{xmlcode}
\caption{Grupo \emph{Geometry} para exemplo detalhado.}
\label{lst:grupgeometryex}
\end{listing} %$

Em seguida, é necessário definir os parâmetros dos fluidos e rochas considerados no grupo \emph{Physical}. Os valores para as propriedades dos fluidos e de interação rocha-fluidos são informados do mesmo modo que na Listagem \ref{lst:arqphysxml}. Já as propriedades das rochas devem ser informadas utilizando dois blocos do tipo \verb|rock-properties|, um para cada domínio (regiões de alta e de baixa permeabilidade). No caso de existirem outros domínios, basta adicionar quantas seções foram necessárias, já que a leitura de dados de entrada é suficientemente flexível para só considerar os dados de interesse, desde que o ID da rocha adicionada corresponda ao \emph{flag} dos elementos no arquivo de malha (comando \verb|Physical Surface| no arquivo de geometria). Os dados para este exemplo específico são mostrados a seguir:
\begin{listing}[H]
\begin{xmlcode}
<rock-properties>
       <rock-type id="352">
           <porosity compressible="no">1.0</porosity>
           <permeability type="per-domain">
               <Kxx>0.0001</Kxx>
               <Kxy>0.0</Kxy>
               <Kyy>0.0001</Kyy>
           </permeability>
       </rock-type>
       <rock-type id="353">
           <porosity compressible="no">1.0</porosity>
           <permeability type="per-domain">
               <Kxx>1</Kxx>
               <Kxy>0.0</Kxy>
               <Kyy>1</Kyy>
           </permeability>
       </rock-type>
</rock-properties>
\end{xmlcode}
\caption{Propriedades das rochas.}
\label{lst:physrockex}
\end{listing} %$

Por fim, os parâmetros numéricos para a simulação são fornecidos dentro do grupo \emph{Numerical}. Para a solução do problema elíptico utilizaremos a formulação do \acf{MEFM} devido à sua característica de calcular simultaneamente os campos de pressão e de velocidade (ver Cap. \ref{ch:form_num} para detalhes). Já para a solução do problema hiperbólico, foi utilizada a estabilização da solução via \acf{SUPG} e um termo de difusão artificial isotrópica para redução das oscilações espúrias conforme descrito em \citep{Wells2008}. O trecho a seguir mostra os dados utilizados para este exemplo:
\begin{listing}[H]
\begin{xmlcode}
<numerical>
   <pressure-solver formulation="mixedfem" type="gmres">
       <tolerance>1e-10</tolerance>
       <max-number-steps>1000</max-number-steps>
       <pre-conditioning type="none">
           <number-coarse-levels>5</number-coarse-levels>
       </pre-conditioning>
   </pressure-solver>
   <saturation-solver>
       <total-time-analysis>200</total-time-analysis>            
       <courant>0.9</courant>
       <limiter type="SUPG+Wells"/>
   </saturation-solver>
</numerical>
\end{xmlcode}
\caption{Grupo \emph{Numerical} para exemplo detalhado.}
\label{lst:arqnumxmlex}
\end{listing} %$

Uma vez prontos os arquivos de malha e de dados (o qual nomearemos como \verb|ExampleCase.xml|), podemos executar o \emph{Delfine} a partir do terminal utilizando o seguinte comando:
\begin{listing}[H]
\begin{bashcode}
$ ./run.py ExampleCase.xml
\end{bashcode}
\caption{Execução do caso gerado como exemplo.}
\label{lst:execucaoexemplo}
\end{listing} %$

A partir deste momento, o programa irá executar todos os passos automaticamente, informando a respeito do passo de tempo da solução no qual se encontra. Ao final, os arquivos com os resultados dos campos de pressão, velocidade e saturação são escritos na pasta  \verb|Delfine/Results|. O formato dos arquivos é o \verb|*.vtk|, o qual pode ser aberto utilizando programas como o \emph{Paraview} ou o \emph{VisIt}.
